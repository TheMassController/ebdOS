@This file is generated by GCC, hence the huge amount of compiler instructions. 
@The assembly is manually optimized
@This file contains the defs of the following global vars:
@   struct Process* currentProcess = NULL
	.syntax unified
    .thumb
    .file   "scheduling.c"
    .global currentProcess
    .section    .bss.currentProcess,"aw",%nobits
    .align  2
    .type   currentProcess, %object
    .size   currentProcess, 4
currentProcess:
    .space  4
    .section    .text.pendSVHandler,"ax",%progbits
    .align  2
    .global pendSVHandler
    .thumb
    .thumb_func
    .type   pendSVHandler, %function
pendSVHandler:
	@ args = 0, pretend = 0, frame = 8
	@ frame_needed = 0, uses_anonymous_args = 0
    cpsid i         @Disables all interrupts

    @First: the check if we even need to context switch
	ldr	r2, .L4                 @Load L4+0, which is currentprocess (r2 = &currentProcess)
	ldr	r3, .L4+4               @Load l4+4, which is processesReady (r3 = &processesReady)
	ldr	r1, [r2]                @Deref (r1 = currentProcess)
	ldr	r3, [r3]                @Deref r3 (r3 = processesReady)
    cmp r1, r3                  @If the next process is equal to the current one
    beq .L3                     @Do not switch context, but return
    
    @The r0, r1, r2, r3, r12, LR, PC and XPSR registers are already pushed to the currently active stack on interrupt.
    @This function adds the other registers to the stack and then changes the stack.
    @Then it does the inverse for the function that is being switched to.

    @Actual context switch
    mrs r0, psp                 @Move the PSP to R0
    and lr, lr, #0x10           @Test if the 5th bit is 0
    ldr r12, [r1, #8]           @r12 = savedRegsPointer of currentProcess
    str lr, [r1, #12]           @write the data about the fp flag
	str	r0, [r1]                @Save the stackpointer of currentProcess (currentProcess->stackPointer = r0)
    stmdb r12!, {r4-r11}        @Move R4 to R11 to the mem r12 points to, while decreasing 12. Decrement before, so first decrement, then write, decrement, write etc
    cmp lr, #0x0                @test if we need to save the fp regs
    bne .L6                     @Skip fp saving
    vstmdb.f32 r12!, {s16-s31}  @Move FP regs to mem. Decrement before
.L6:
	ldr	r0, [r3, #8]            @Deref r3 + 8 (r0 = processesReady->savedRegsPointer)
    str r12, [r1, #8]           @Store the moved savedRegsPointer of the currentprocess to the mem of the currentprocess
    ldr lr, [r3, #12]           @Load the "use FP" flag
    cmp lr, #0x0                @test if we need to load the fp regs
    bne .L7                     @if not, skip
    vldmia.f32 r0!, {s16-s31}   @Load the fp regs
.L7:
    ldr r12, [r3]               @Load the sp of the new process
    ldmia   r0! , {r4-r11}      @Move from ram to regs while increasing R0. Increment after, so load, increment, load, increment etc
    msr psp, r12                @push r12 to psp
    str r0, [r3, #8]            @Store the moved savedRegsPointer

    @Update pointers
	str	r3, [r2]                @currentProcess = top of processesReady
    
    @Decide the returnvar and return
	ldr	r1, [r3, #4]            @Get the second variable of processesReady. This is the pid and 1 for the kernel
	cmp	r1, #1                  @Test if that var is 1
	beq	.L2                     @Branch if it is not 1
    cmp lr, #0x0                @Test if we need FP after context switch
    beq .L8
	mvn	lr, #2                  @lr = 0xFFFFFFFD (Continue from PSP, no hardware FP)
    b .L3
.L8:
    mvn lr, #0x12               @lr = 0xFFFFFFED (Continue from PSP, enable hw FP)
    b .L3
.L2:
    cmp lr, #0x0                @Test if we need FP after context switch
    beq .L9
	mvn	lr, #6                  @lr = 0xFFFFFFF9 (Continue from MSP, no hardware FP)
    b .L3
.L9:
    mvn lr, #0x16               @lr = 0xFFFFFFE9 (Continue from MSP, enable hw FP)
.L3:
    cpsie i                     @Reenable all interrupts
    bx lr                       @Branch to LR-addr (lr->pc) (mov pc, lr leads to hard fault for some reason)
.L5:
	.align	2
.L4:
	.word	currentProcess
	.word	processesReady
	.size	pendSVHandler, .-pendSVHandler
