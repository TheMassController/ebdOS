@This file is generated by GCC, hence the huge amount of compiler instructions. 
@The assembly is manually optimized
@This file contains the defs of the following global vars:
@   struct Process* currentProcess = NULL
	.syntax unified
	.cpu cortex-m4
	.eabi_attribute 27, 3
	.fpu vfp
	.eabi_attribute 20, 1
	.eabi_attribute 21, 1
	.eabi_attribute 23, 3
	.eabi_attribute 24, 1
	.eabi_attribute 25, 1
	.eabi_attribute 26, 1
	.eabi_attribute 30, 6
	.eabi_attribute 34, 1
	.eabi_attribute 18, 4
    .thumb
    .file   "scheduling.c"
    .global currentProcess
    .section    .bss.currentProcess,"aw",%nobits
    .align  2
    .type   currentProcess, %object
    .size   currentProcess, 4
currentProcess:
    .space  4
    .section    .text.pendSVHandler,"ax",%progbits
    .align  2
    .global pendSVHandler
    .thumb
    .thumb_func
    .type   pendSVHandler, %function
pendSVHandler:
	@ args = 0, pretend = 0, frame = 8
	@ frame_needed = 0, uses_anonymous_args = 0
    cpsid i         @Disables all interrupts

    @First: the check if we even need to context switch
	ldr	r2, .L4     @Load L4+0, which is currentprocess (r2 = &currentProcess)
	ldr	r3, .L4+4   @Load l4+4, which is processesReady (r3 = &processesReady)
	ldr	r1, [r2]    @Deref (r1 = currentProcess)
	ldr	r3, [r3]    @Deref r3 (r3 = processesReady)
    cmp r1, r3      @If the next process is equal to the current one
    beq .L3         @Do not switch context, but return
    
    @The r0, r1, r2, r3, r12, LR, PC and XPSR registers are already pushed to the currently active stack on interrupt.
    @This function adds the other registers to the stack and then changes the stack.
    @Then it does the inverse for the function that is being switched to.

    @Actual context switch
    mrs r0, psp     @Move the PSP to R0
    stmdb r0!, {r4-r11}    @Move R4 to R11 to param R0, while decreasing R0
	str	r0, [r1]    @Update the stackpointer of currentProcess (currentProcess->stackPointer = r0)
	ldr	r0, [r3]    @Deref r3 (r0 = processesReady->stackPointer)
    ldmfd   r0! , {r4-r11}      @Move from ram to regs while increasing R0
    msr psp, r0     @push r0 to psp

	str	r3, [r2] @currentProcess = processesReady
    
    @Decide the returnvar and return
	ldr	r3, [r3, #4]    @Get the second variable of processesReady. This is the pid and 1 for the kernel
	cmp	r3, #1      @Test if that var is 1
	beq	.L2         @Branch if it is not 1
	mvn	lr, #2 @lr = 0xFFFFFFFD (Continue from PSP, no hardware FP)
    b .L3
.L2:
	mvn	lr, #6  @lr = 0xFFFFFFF9 (Continue from MSP, no hardware FP)
.L3:
    cpsie i         @Reenable all interrupts
    bx lr           @Branch to LR-addr (lr->pc) (mov pc, lr leads to hard fault for some reason)
.L5:
	.align	2
.L4:
	.word	currentProcess
	.word	processesReady
	.size	pendSVHandler, .-pendSVHandler
