@This file is generated by GCC, hence the huge amount of compiler instructions. 
@The assembly is manually optimized
@This file contains the defs of the following global vars:
@   struct Process* currentProcess = NULL
	.syntax unified
    .thumb
    .file   "scheduling.c"
    .global currentProcess
    .section    .bss.currentProcess,"aw",%nobits
    .align  2
    .type   currentProcess, %object
    .size   currentProcess, 4
currentProcess:
    .space  4
    .section    .text.pendSVHandler,"ax",%progbits
    .align  2
    .global pendSVHandler
    .thumb
    .thumb_func
    .type   pendSVHandler, %function
pendSVHandler:
	@ args = 0, pretend = 0, frame = 8
	@ frame_needed = 0, uses_anonymous_args = 0
    cpsid i         @Disables all interrupts

    @First: the check if we even need to context switch
	ldr	r2, .L4                 @Load L4+0, which is currentprocess (r2 = &currentProcess)
	ldr	r3, .L4+4               @Load l4+4, which is processesReady (r3 = &processesReady)
	ldr	r1, [r2]                @Deref (r1 = currentProcess)
	ldr	r3, [r3]                @Deref r3 (r3 = processesReady)
    cmp r1, r3                  @If the next process is equal to the current one
    beq .L3                     @Do not switch context, but return
    
    @The r0, r1, r2, r3, r12, LR, PC and XPSR registers are already pushed to the currently active stack on interrupt.
    @This function pushes the other regs to the process control block.
    @Then it loads the other regs from the process control block of the next process.

    @Update pointers
	str	r3, [r2]                @currentProcess = top of processesReady

    @Actual context switch
    ldr r2, [r1, #12]           @Load the flags
    ands lr, lr, #0x10          @Test if the 5th bit is 0. UPDATES THE CONDITION FLAGS FOR THE FP INSTRUCTION LATER
    itt eq                      @Start an eq block
    orreq r2, r2, #0x2          @Set the FP flag if the last outcome was equal. (there was a zero at the end of the ALU)
    streq r2, [r1, #12]         @write the data about the fp flag to currentProcess
    ldr r12, [r1, #8]           @r12 = savedRegsPointer of currentProcess
    stmdb r12!, {r4-r11}        @Move R4 to R11 to the mem r12 points to, while decreasing 12. Decrement before, so first decrement, then write, decrement, write etc
    it eq                       @start conditional block for eq.
    vstmdbeq.f32 r12!, {s16-s31}@Move FP regs to mem. Decrement before. CONDITIONAL EXECUTION only when zero flag was set (is equal)
    str r12, [r1, #8]           @Store the moved savedRegsPointer of the currentprocess to the mem of the currentprocess
    mrs r0, psp                 @Move the PSP to R0
	str	r0, [r1]                @Save the stackpointer of currentProcess (currentProcess->stackPointer = r0)

    ldr lr, [r3, #12]           @Load the "use FP" flag
    ands r12, lr, #0x2          @Test the FP flag UPDATES THE CONDITION FLAGS
	ldr	r0, [r3, #8]            @Deref r3 + 8 (r0 = processesReady->savedRegsPointer)
    it ne                       @start conditional block for eq
    vldmiane.f32 r0!, {s16-s31} @Load the fp regs. Increment after. CONDITIONAL EXECUTION only when zero flag was set (is equal)
    ldmia   r0! , {r4-r11}      @Move from ram to regs while increasing R0. Increment after, so load, increment, load, increment etc
    str r0, [r3, #8]            @Store the moved savedRegsPointer
    ldr r2, [r3]                @Load the sp of the new process
    msr psp, r2                 @push r2 (= new stackpointer) to psp
    rbit lr, lr                 @reverse the LR bits. If the exection mode is privileged then we want r12 to become 0x0, so we need this lsb to become zero and it was one. And vice versa
    and r12, lr, #0x1           @Set the privilege flag in r12
    msr CONTROL, r12            @Write the privilege flag to control

    
    @Decide the returnvar and return
    mvn lr, #0x16               @lr = 0xFFFFFFE9 (Continue from MSP, enable hw FP)
    it ne                       @The last CMP was to check wether the process uses FP, recycle this information for the retval
    orrne lr, lr, #0x10         @if nextProc does not use fp: lr = 0xFFFFFFF9 (Continue from MSP, no hardware FP)
	ldr	r1, [r3, #4]            @Get the second variable of processesReady. This is the pid and 1 for the kernel
	cmp	r1, #1                  @Test if that var is 1. If it is: use MSP. Else: use PSP.
    it ne                       @Test for not equal
    orrne lr, lr, #0x4          @If not equal, lr = 0xFFFFFFED (Continue from PSP, enable hw FP) or lr = 0xFFFFFFFD (Continue from PSP, no hardware FP)
.L3:
    cpsie i                     @Reenable all interrupts
    bx lr                       @Branch to LR-addr (lr->pc) (mov pc, lr leads to hard fault for some reason)
.L4:
	.word	currentProcess
	.word	processesReady
	.size	pendSVHandler, .-pendSVHandler
