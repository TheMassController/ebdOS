@This file is generated by GCC, hence the huge amount of compiler instructions. 
@The assembly is manually optimized
@This file contains the defs of the following global vars:
@   struct Process* currentProcess = NULL
	.syntax unified
    .thumb
    .file   "scheduling.c"
    .global currentProcess
    .section    .bss.currentProcess,"aw",%nobits
    .align  2
    .type   currentProcess, %object
    .size   currentProcess, 4
currentProcess:
    .space  4
    .section    .text.pendSVHandler,"ax",%progbits
    .align  2
    .global pendSVHandler
    .thumb
    .thumb_func
    .type   pendSVHandler, %function
pendSVHandler:
	@ args = 0, pretend = 0, frame = 8
	@ frame_needed = 0, uses_anonymous_args = 0
    cpsid i         @Disables all interrupts

    @First: the check if we even need to context switch
	ldr	r2, .L4                 @Load L4+0, which is currentprocess (r2 = &currentProcess)
	ldr	r3, .L4+4               @Load l4+4, which is processesReady (r3 = &processesReady)
	ldr	r1, [r2]                @Deref (r1 = currentProcess)
	ldr	r3, [r3]                @Deref r3 (r3 = processesReady)
    cmp r1, r3                  @If the next process is equal to the current one
    beq .L3                     @Do not switch context, but return
    
    @The r0, r1, r2, r3, r12, LR, PC and XPSR registers are already pushed to the currently active stack on interrupt.
    @This function pushes the other regs to the process control block.
    @Then it loads the other regs from the process control block of the next process.

    @Update pointers
	str	r3, [r2]                @currentProcess = top of processesReady

    @Actual context switch
    ldr r2, [r1, #12]           @Load the flags
    and lr, lr, #0x10           @Test if the 5th bit is 0. 
    cmp lr, #0x10               @Compares to see if the FPU is currently activated. UPDATES THE CONDITION FLAGS FOR THE FP INSTRUCTION LATER
    itt ne                      @Start an test block
    orrne r2, r2, #0x2          @Set the FP flag if the last outcome was not equal. If it was not equal then the FPU is in use 
    strne r2, [r1, #12]         @write the data about the fp flag to currentProcess
    ldr r12, [r1, #8]           @r12 = savedRegsPointer of currentProcess
    stmdb r12!, {r4-r11}        @Move R4 to R11 to the mem r12 points to, while decreasing 12. Decrement before, so first decrement, then write, decrement, write etc
    it ne                       @If the fpu was activated, we need to switch out the fpu regs
    vstmdbne.f32 r12!, {s16-s31}@Move FP regs to mem. Decrement before. Conditional execution. Triggers lazy stacking.
    str r12, [r1, #8]           @Store the moved savedRegsPointer of the currentprocess to the mem of the currentprocess
    mrs r0, psp                 @Move the PSP to R0
	str	r0, [r1]                @Save the stackpointer of currentProcess (currentProcess->stackPointer = r0)

    ldr lr, [r3, #12]           @Load the hw flags
    and r12, lr, #0x1           @Isolate the first bit, the privileged bit
    cmp r12, #0x1               @Test if the bit is set
    ite ne                      @if not..
    movne r12, #0x1             @Then set r12 to 1
    moveq r12, #0x0             @else set r12 to 0
    msr CONTROL, r12            @Write the r12 to CONTROL to set the privilege
    and r12, lr, #0x2           @Isolate the FPU flag
    cmp r12, #0x2               @Test if it is set
	ldr	r0, [r3, #8]            @Deref r3 + 8 (r0 = processesReady->savedRegsPointer)
    it eq                       @start conditional block for eq
    vldmiaeq.f32 r0!, {s16-s31} @Load the fp regs. Increment after. CONDITIONAL EXECUTION only when zero flag was set (is equal)
    ldmia   r0! , {r4-r11}      @Move from ram to regs while increasing R0. Increment after, so load, increment, load, increment etc
    str r0, [r3, #8]            @Store the moved savedRegsPointer
    ldr r2, [r3]                @Load the sp of the new process
    msr psp, r2                 @push r2 (= new stackpointer) to psp

    
    @Decide the returnvar and return
    mvn lr, #0x16               @lr = 0xFFFFFFE9 (Continue from MSP, enable hw FP)
    it ne                       @The last CMP was to check wether the process uses FP, recycle this information for the retval
    orrne lr, lr, #0x10         @if nextProc does not use fp: lr = 0xFFFFFFF9 (Continue from MSP, no hardware FP)
	ldr	r1, [r3, #4]            @Get the second variable of processesReady. This is the pid and 1 for the kernel
	cmp	r1, #1                  @Test if that var is 1. If it is: use MSP. Else: use PSP.
    it ne                       @Test for not equal
    orrne lr, lr, #0x4          @If not equal, lr = 0xFFFFFFED (Continue from PSP, enable hw FP) or lr = 0xFFFFFFFD (Continue from PSP, no hardware FP)
.L3:
    cpsie i                     @Reenable all interrupts
    bx lr                       @Branch to LR-addr (lr->pc) (mov pc, lr leads to hard fault for some reason)
.L4:
	.word	currentProcess
	.word	processesReady
	.size	pendSVHandler, .-pendSVHandler
